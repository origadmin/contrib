package main

import (
	"crypto/sha256"
	"encoding/hex"
	"flag"
	"fmt"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"

	policyv1 "github.com/origadmin/contrib/api/gen/go/policy/v1" // Corrected import path
)

const version = "1.0.8"

var showVersion = flag.Bool("version", false, "print the version and exit")

// policyInfo is a helper struct to store parsed policy information before generation.
type policyInfo struct {
	ServiceMethod string
	GatewayPath   string
	Name          string
	VersionID     string
}

func main() {
	flag.Parse()
	if *showVersion {
		fmt.Printf("protoc-gen-go-security %s\n", version)
		return
	}

	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

// generateFile generates a .pb.security.go file containing policy registrations.
// It first collects all methods with policy annotations and then generates the file.
func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}

	// 1. Collect all policies from the file first.
	var policies []policyInfo
	for _, service := range file.Services {
		for _, method := range service.Methods {
			policyName := getPolicyName(method)
			// Only generate an entry if a policy is actually declared.
			if policyName == "" {
				continue
			}

			serviceMethod := fmt.Sprintf("/%s/%s", service.Desc.FullName(), method.Desc.Name())
			gatewayPath := getGatewayPath(method)
			versionID := calculateVersionID(serviceMethod, gatewayPath, policyName)
			policies = append(policies, policyInfo{
				ServiceMethod: serviceMethod,
				GatewayPath:   gatewayPath,
				Name:          policyName,
				VersionID:     versionID,
			})
		}
	}

	// 2. If no policies were found, do not generate the file.
	if len(policies) == 0 {
		return
	}

	// 3. Generate the file content.
	filename := file.GeneratedFilenamePrefix + ".pb.security.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-go-security. DO NOT EDIT.")
	g.P("// version: ", version)
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Add necessary imports.
	g.P("import (")
	g.P(`	security "github.com/origadmin/contrib/security"`)
	g.P(")")
	g.P()

	g.P("func init() {")
	g.P("	policies := []security.Policy{")

	for _, p := range policies {
		g.P("		{")
		g.P(`			ServiceMethod: "`, p.ServiceMethod, `",`)
		g.P(`			GatewayPath:   "`, p.GatewayPath, `",`)
		g.P(`			Name:          "`, p.Name, `",`)
		g.P(`			VersionID:     "`, p.VersionID, `",`)
		g.P("		},")
	}

	g.P("	}")
	g.P()
	g.P("	security.RegisterPolicies(policies)")
	g.P("}")
}

func getPolicyName(method *protogen.Method) string {
	opts, ok := method.Desc.Options().(*descriptorpb.MethodOptions)
	if !ok {
		return ""
	}
	ext := proto.GetExtension(opts, policyv1.E_Policy)
	rule, ok := ext.(*policyv1.Policy)
	if !ok || rule == nil {
		return ""
	}
	return rule.Name
}

func getGatewayPath(method *protogen.Method) string {
	opts, ok := method.Desc.Options().(*descriptorpb.MethodOptions)
	if !ok {
		return ""
	}
	ext := proto.GetExtension(opts, annotations.E_Http)
	rule, ok := ext.(*annotations.HttpRule)
	if !ok || rule == nil {
		return ""
	}

	var httpMethod, httpPath string
	switch t := rule.Pattern.(type) {
	case *annotations.HttpRule_Get:
		httpMethod, httpPath = "GET", t.Get
	case *annotations.HttpRule_Post:
		httpMethod, httpPath = "POST", t.Post
	case *annotations.HttpRule_Put:
		httpMethod, httpPath = "PUT", t.Put
	case *annotations.HttpRule_Delete:
		httpMethod, httpPath = "DELETE", t.Delete
	case *annotations.HttpRule_Patch:
		httpMethod, httpPath = "PATCH", t.Patch
	case *annotations.HttpRule_Custom:
		httpMethod, httpPath = t.Custom.Kind, t.Custom.Path
	}

	if httpMethod != "" && httpPath != "" {
		return fmt.Sprintf("%s:%s", httpMethod, httpPath)
	}
	return ""
}

// calculateVersionID computes a stable hash for a policy definition.
func calculateVersionID(serviceMethod, gatewayPath, policyName string) string {
	var data []byte
	data = append(data, serviceMethod...)
	data = append(data, '|')
	data = append(data, gatewayPath...)
	data = append(data, '|')
	data = append(data, policyName...)

	hash := sha256.Sum256(data)
	return hex.EncodeToString(hash[:])
}
